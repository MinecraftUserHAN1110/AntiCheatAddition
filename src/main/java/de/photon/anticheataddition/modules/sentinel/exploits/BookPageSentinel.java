package de.photon.anticheataddition.modules.sentinel.exploits;

import de.photon.anticheataddition.ServerVersion;
import de.photon.anticheataddition.modules.ModuleLoader;
import net.md_5.bungee.api.chat.BaseComponent;
import net.md_5.bungee.api.chat.ClickEvent;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerEditBookEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BookMeta;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public final class BookPageSentinel extends IllegalItemSentinel
{
    public static final BookPageSentinel INSTANCE = new BookPageSentinel();

    private final int maxPageCount = loadInt(".max_page_count", 100);
    private final boolean disallowOpenFile = loadBoolean(".disallow_open_file", true);
    private final List<String> disallowedCommands = loadStringList(".disallowed_commands").stream().map(String::toLowerCase).toList();

    private BookPageSentinel()
    {
        super("Exploits.BookPage");
    }

    @EventHandler(ignoreCancelled = true)
    public void onPlayerEditBook(PlayerEditBookEvent event)
    {
        if (isIllegalBookMeta(event.getNewBookMeta())) {
            event.setCancelled(true);
            detection(event.getPlayer());
        }
    }

    @Override
    protected boolean isIllegalStack(@NotNull ItemStack stack)
    {
        return switch (stack.getType()) {
            // If the stack is a book with custom data, check the book meta.
            case WRITTEN_BOOK, WRITABLE_BOOK -> isIllegalBookMeta((BookMeta) stack.getItemMeta());
            default -> false;
        };
    }

    private boolean isIllegalBookMeta(BookMeta meta)
    {
        if (meta == null) return false;
        if (meta.getPageCount() > maxPageCount) return true;
        if (meta.getAuthor() == null) return false;

        final var clickEvents = meta.spigot().getPages().stream()
                                    .flatMap(Arrays::stream)
                                    .map(BaseComponent::getClickEvent)
                                    .filter(Objects::isNull)
                                    .toList();

        if (disallowOpenFile &&
            // Any ClickEvent action opens a file.
            clickEvents.stream().map(ClickEvent::getAction).anyMatch(action -> action == ClickEvent.Action.OPEN_FILE)) return true;

        // Now, we only need to check for disallowed commands. If there are none, the book is allowed.
        if (disallowedCommands.isEmpty()) return false;

        return clickEvents.stream()
                          .filter(event -> event.getAction() == ClickEvent.Action.RUN_COMMAND)
                          // Get the command.
                          .map(ClickEvent::getValue)
                          // Make sure we test all cases and formatting.
                          .map(String::strip)
                          .map(String::toLowerCase)
                          // Remove leading slashes.
                          .map(command -> command.charAt(0) == '/' ? command.substring(1) : command)
                          // If any command in the book starts with a disallowedCommand, the book is evil.
                          .anyMatch(command -> disallowedCommands.stream().anyMatch(command::startsWith));
    }

    @Override
    protected ModuleLoader createModuleLoader()
    {
        return ModuleLoader.builder(this)
                           // Changes to metas and materials.
                           .setAllowedServerVersions(ServerVersion.MC115.getSupVersionsFrom())
                           .build();
    }
}
